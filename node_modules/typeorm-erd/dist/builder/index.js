"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.builders = void 0;
const ConnectionMetadataBuilder_1 = require("typeorm/connection/ConnectionMetadataBuilder");
const entityMetaData = async (connection) => {
    const connectionMetadataBuilder = new ConnectionMetadataBuilder_1.ConnectionMetadataBuilder(connection);
    const { entities } = connection.options;
    const TEntities = entities;
    let entityMetadata;
    if (entities) {
        entityMetadata = await connectionMetadataBuilder.buildEntityMetadatas(TEntities);
    }
    else {
        throw Error("No entities found on connection");
    }
    return entityMetadata;
};
/**
 * Return the relation data for each table
 *
 */
const relations = (meta) => {
    const relationData = meta.reduce((acc, entity) => {
        const entityRelations = entity.relations.map((rel) => handleRelation(entity, rel));
        return {
            ...acc,
            [entity.tableName]: {
                entityRelations,
            },
        };
    }, {});
    return relationData;
};
exports.builders = {
    entityMetaData,
    relations,
};
// Private
/**
 * Resolve entity relationships to a normalised entity to entity relation even
 * when there are join tables
 */
const handleRelation = (entity, { relationType, inverseEntityMetadata, propertyPath, inverseSidePropertyPath, isOwning, joinTableName, inverseRelation, }) => {
    const column = entity.columns.find((c) => c.propertyName === propertyPath);
    const nullable = column ? column.isNullable : false;
    let target = inverseEntityMetadata.tableName;
    let derivedRelationType = relationType;
    let derivedJoinTable = inverseRelation && inverseRelation.joinTableName
        ? inverseRelation.joinTableName
        : joinTableName;
    let derivedOwnership = isOwning;
    if (derivedJoinTable) {
        target = derivedJoinTable;
        derivedRelationType = "one-to-many";
        derivedOwnership = true;
    }
    return {
        relationType: derivedRelationType,
        propertyPath,
        isOwning: derivedOwnership,
        nullable,
        inverseSidePropertyPath,
        source: entity.tableName,
        joinTableName: derivedJoinTable,
        target,
    };
};
