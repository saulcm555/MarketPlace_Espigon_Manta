# Implementaci√≥n de Tablas Transaccionales - MarketPlace Espig√≥n Manta

## üìã Resumen

Este documento explica la implementaci√≥n de las **tablas transaccionales** (tablas intermedias para relaciones many-to-many) en el sistema de MarketPlace. Se implementaron dos tablas transaccionales principales:

1. **ProductCart** - Relaci√≥n entre `Cart` y `Product`
2. **ProductOrder** - Relaci√≥n entre `Order` y `Product`

---

## üèóÔ∏è Arquitectura

El proyecto sigue una **Clean Architecture** con las siguientes capas:

```
src/
‚îú‚îÄ‚îÄ domain/              # Entidades y l√≥gica de negocio
‚îú‚îÄ‚îÄ application/         # Casos de uso y DTOs
‚îú‚îÄ‚îÄ infrastructure/      # Implementaciones (DB, HTTP, etc.)
‚îî‚îÄ‚îÄ models/             # Modelos TypeORM
```

---

## üìä Tablas Transaccionales Implementadas

### 1. ProductCart (product_cart)

Tabla intermedia que conecta carritos con productos, permitiendo que un carrito tenga m√∫ltiples productos y viceversa.

**Estructura:**
```typescript
@Entity({ name: "product_cart" })
export class ProductCartEntity {
  @PrimaryGeneratedColumn({ name: "id_product_cart" })
  id_product_cart!: number;

  @Column({ name: "id_product" })
  id_product!: number;

  @Column({ name: "id_cart" })
  id_cart!: number;

  @Column({ name: "quantity", type: "int" })
  quantity!: number;

  @CreateDateColumn({ name: "added_at" })
  added_at!: Date;

  @UpdateDateColumn({ name: "updated_at" })
  updated_at!: Date;

  @ManyToOne(() => ProductEntity)
  @JoinColumn({ name: "id_product" })
  product!: ProductEntity;

  @ManyToOne(() => CartEntity)
  @JoinColumn({ name: "id_cart" })
  cart!: CartEntity;
}
```

**Ubicaci√≥n del modelo:** `src/models/cartModel.ts`

---

### 2. ProductOrder (product_order)

Tabla intermedia que conecta √≥rdenes con productos, almacenando informaci√≥n adicional como cantidad y precio unitario al momento de la compra.

**Estructura:**
```typescript
@Entity({ name: "product_order" })
export class ProductOrderEntity {
  @PrimaryGeneratedColumn({ name: "id_product_order" })
  id_product_order!: number;

  @Column({ name: "id_product" })
  id_product!: number;

  @Column({ name: "id_order" })
  id_order!: number;

  @Column({ name: "quantity", type: "int" })
  quantity!: number;

  @Column({ name: "price_unit", type: "decimal", precision: 10, scale: 2 })
  price_unit!: number;

  @ManyToOne(() => ProductEntity)
  @JoinColumn({ name: "id_product" })
  product!: ProductEntity;

  @ManyToOne(() => OrderEntity)
  @JoinColumn({ name: "id_order" })
  order!: OrderEntity;
}
```

**Ubicaci√≥n del modelo:** `src/models/orderModel.ts`

---

## üîß Casos de Uso Implementados

### ProductCart - Casos de Uso

#### 1. AddProductToCart
**Prop√≥sito:** Agregar un producto a un carrito espec√≠fico

**Archivo:** `src/application/use_cases/cart/AddProductToCart.ts`

**Funcionalidad:**
- Valida que el carrito y producto existan
- Verifica stock disponible
- Si el producto ya est√° en el carrito, actualiza la cantidad
- Si no existe, crea un nuevo registro en ProductCart

**DTO:** `src/application/dtos/cart/AddProductToCart.dto.ts`
```typescript
export interface AddProductToCartDto {
  id_cart: number;
  id_product: number;
  quantity: number;
}
```

---

#### 2. RemoveProductFromCart
**Prop√≥sito:** Eliminar un producto del carrito

**Archivo:** `src/application/use_cases/cart/RemoveProductFromCart.ts`

**Funcionalidad:**
- Busca el producto en el carrito usando `id_cart` e `id_product`
- Elimina el registro de ProductCart

**DTO:** `src/application/dtos/cart/RemoveProductFromCart.dto.ts`
```typescript
export interface RemoveProductFromCartDto {
  id_cart: number;
  id_product: number;
}
```

---

#### 3. UpdateCartItemQuantity
**Prop√≥sito:** Actualizar la cantidad de un producto en el carrito

**Archivo:** `src/application/use_cases/cart/UpdateCartItemQuantity.ts`

**Funcionalidad:**
- Busca el producto en el carrito
- Valida que haya stock suficiente
- Actualiza la cantidad en ProductCart
- Actualiza la fecha de modificaci√≥n

**DTO:** `src/application/dtos/cart/UpdateCartItemQuantity.dto.ts`
```typescript
export interface UpdateCartItemQuantityDto {
  id_cart: number;
  id_product: number;
  quantity: number;
}
```

---

#### 4. GetCartWithProducts
**Prop√≥sito:** Obtener un carrito con todos sus productos

**Archivo:** `src/application/use_cases/cart/GetCartWithProducts.ts`

**Funcionalidad:**
- Obtiene el carrito con sus relaciones (ProductCart y Product)
- Incluye informaci√≥n del cliente
- Devuelve la estructura completa del carrito

---

### ProductOrder - Caso de Uso

#### CreateOrder
**Prop√≥sito:** Crear una orden con sus productos usando transacciones de base de datos

**Archivo:** `src/application/use_cases/orders/CreateOrder.ts`

**Funcionalidad:**
- **Usa transacciones de BD** para garantizar integridad de datos
- Crea la orden principal
- Itera sobre los productos y crea registros en ProductOrder
- Actualiza el stock de cada producto
- Si algo falla, hace rollback de todos los cambios

**DTO:** `src/application/dtos/orders/CreateOrder.dto.ts`
```typescript
export interface CreateOrderDto {
  id_client: number;
  id_cart: number;
  id_payment_method: number;
  delivery_type: string;
  delivery_address?: string;
  productOrders?: {
    id_product: number;
    quantity: number;
    price_unit: number;
  }[];
}
```

**C√≥digo clave - Transacci√≥n:**
```typescript
const queryRunner = AppDataSource.createQueryRunner();
await queryRunner.connect();
await queryRunner.startTransaction();

try {
  // 1. Crear orden
  const order = await queryRunner.manager.save(OrderEntity, newOrder);

  // 2. Crear ProductOrder para cada producto
  for (const productOrder of data.productOrders) {
    const productOrderEntity = queryRunner.manager.create(ProductOrderEntity, {
      id_order: order.id_order,
      id_product: productOrder.id_product,
      quantity: productOrder.quantity,
      price_unit: productOrder.price_unit,
    });
    await queryRunner.manager.save(productOrderEntity);

    // 3. Actualizar stock
    await queryRunner.manager.update(
      ProductEntity,
      { id_product: productOrder.id_product },
      { stock: () => `stock - ${productOrder.quantity}` }
    );
  }

  await queryRunner.commitTransaction();
  return order;
} catch (error) {
  await queryRunner.rollbackTransaction();
  throw error;
} finally {
  await queryRunner.release();
}
```

---

## üåê Endpoints API

### ProductCart Endpoints

| M√©todo | Endpoint | Descripci√≥n | Autenticaci√≥n |
|--------|----------|-------------|---------------|
| POST | `/api/carts/:id/products` | Agregar producto al carrito | Cliente |
| GET | `/api/carts/:id/with-products` | Obtener carrito con productos | S√≠ |
| PUT | `/api/carts/:id/products/:productId` | Actualizar cantidad | Cliente |
| DELETE | `/api/carts/:id/products/:productId` | Eliminar producto del carrito | Cliente |

**Ejemplo - Agregar producto al carrito:**
```bash
POST /api/carts/1/products
Authorization: Bearer {token}
Content-Type: application/json

{
  "id_product": 1,
  "quantity": 2
}
```

**Respuesta:**
```json
{
  "id_product_cart": 1,
  "id_cart": 1,
  "id_product": 1,
  "quantity": 2,
  "added_at": "2025-10-22T00:00:00.000Z",
  "updated_at": "2025-10-22T00:00:00.000Z"
}
```

---

### ProductOrder Endpoints

| M√©todo | Endpoint | Descripci√≥n | Autenticaci√≥n |
|--------|----------|-------------|---------------|
| POST | `/api/orders` | Crear orden con productos | Cliente |
| GET | `/api/orders/:id` | Obtener orden con productos | S√≠ |

**Ejemplo - Crear orden:**
```bash
POST /api/orders
Authorization: Bearer {token}
Content-Type: application/json

{
  "id_client": 2,
  "id_cart": 1,
  "id_payment_method": 1,
  "delivery_type": "home_delivery",
  "delivery_address": "Calle Principal 123",
  "productOrders": [
    {
      "id_product": 1,
      "quantity": 5,
      "price_unit": 1200.00
    }
  ]
}
```

**Respuesta:**
```json
{
  "id_order": 3,
  "id_client": 2,
  "id_cart": 1,
  "id_payment_method": 1,
  "total_price": "6000.00",
  "order_date": "2025-10-22T00:00:00.000Z",
  "delivery_type": "home_delivery"
}
```

---

## üîê Sistema de Autenticaci√≥n

Se implement√≥ un sistema completo de autenticaci√≥n JWT para proteger los endpoints.

### Endpoints de Autenticaci√≥n

| M√©todo | Endpoint | Descripci√≥n |
|--------|----------|-------------|
| POST | `/api/auth/login/client` | Login de clientes |
| POST | `/api/auth/login/seller` | Login de vendedores |
| POST | `/api/auth/login/admin` | Login de administradores |
| POST | `/api/auth/register/client` | Registro de clientes |
| GET | `/api/auth/verify` | Verificar token JWT |

**Archivos:**
- Controlador: `src/infrastructure/http/controllers/authController.ts`
- Rutas: `src/infrastructure/http/routes/authRoutes.ts`
- Middleware: `src/infrastructure/middlewares/authMiddleware.ts`

**Caracter√≠sticas:**
- Tokens JWT con expiraci√≥n de 24 horas
- Contrase√±as hasheadas con bcrypt (10 salt rounds)
- Roles: client, seller, admin
- Secret key configurable via `JWT_SECRET` (env variable)

---

## üì¶ Endpoints Auxiliares Creados

### Payment Methods
| M√©todo | Endpoint | Descripci√≥n |
|--------|----------|-------------|
| GET | `/api/payment-methods` | Obtener m√©todos de pago |
| GET | `/api/payment-methods/:id` | Obtener m√©todo por ID |
| POST | `/api/payment-methods` | Crear m√©todo (Admin) |
| PUT | `/api/payment-methods/:id` | Actualizar m√©todo (Admin) |
| DELETE | `/api/payment-methods/:id` | Eliminar m√©todo (Admin) |

### Deliveries
| M√©todo | Endpoint | Descripci√≥n |
|--------|----------|-------------|
| GET | `/api/deliveries` | Obtener m√©todos de entrega |
| GET | `/api/deliveries/:id` | Obtener entrega por ID |
| POST | `/api/deliveries` | Crear entrega |
| PUT | `/api/deliveries/:id` | Actualizar entrega |
| DELETE | `/api/deliveries/:id` | Eliminar entrega (Admin) |

---

## üß™ Testing

Se cre√≥ un script completo de pruebas en PowerShell que valida toda la funcionalidad.

**Archivo:** `backend/rest_service/test-transaccionales.ps1`

**Flujo de prueba:**

1. ‚úÖ **Autenticaci√≥n** - Login/Registro de cliente
2. ‚úÖ **Obtener productos** - Lista de productos disponibles
3. ‚úÖ **Crear carrito** - Carrito para el cliente
4. ‚úÖ **Agregar producto al carrito** (ProductCart)
5. ‚úÖ **Obtener carrito con productos** (ProductCart con relaciones)
6. ‚úÖ **Actualizar cantidad** (ProductCart)
7. ‚úÖ **Crear orden** (ProductOrder con transacci√≥n)
8. ‚úÖ **Eliminar producto del carrito** (ProductCart)
9. ‚úÖ **Verificar carrito vac√≠o**

**Ejecutar pruebas:**
```powershell
cd backend/rest_service
.\test-transaccionales.ps1
```

---

## üóÇÔ∏è Estructura de Archivos

### ProductCart
```
src/
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îî‚îÄ‚îÄ cartModel.ts                        # ProductCartEntity
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ entities/
‚îÇ       ‚îî‚îÄ‚îÄ cart.ts                         # Interfaz ProductCart
‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îú‚îÄ‚îÄ dtos/cart/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AddProductToCart.dto.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RemoveProductFromCart.dto.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UpdateCartItemQuantity.dto.ts
‚îÇ   ‚îî‚îÄ‚îÄ use_cases/cart/
‚îÇ       ‚îú‚îÄ‚îÄ AddProductToCart.ts
‚îÇ       ‚îú‚îÄ‚îÄ RemoveProductFromCart.ts
‚îÇ       ‚îú‚îÄ‚îÄ UpdateCartItemQuantity.ts
‚îÇ       ‚îî‚îÄ‚îÄ GetCartWithProducts.ts
‚îî‚îÄ‚îÄ infrastructure/
    ‚îî‚îÄ‚îÄ http/
        ‚îú‚îÄ‚îÄ controllers/
        ‚îÇ   ‚îî‚îÄ‚îÄ cartController.ts
        ‚îî‚îÄ‚îÄ routes/
            ‚îî‚îÄ‚îÄ cartRoutes.ts
```

### ProductOrder
```
src/
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îî‚îÄ‚îÄ orderModel.ts                       # ProductOrderEntity
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ entities/
‚îÇ       ‚îî‚îÄ‚îÄ order.ts                        # Interfaz ProductOrder
‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îú‚îÄ‚îÄ dtos/orders/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreateOrder.dto.ts
‚îÇ   ‚îî‚îÄ‚îÄ use_cases/orders/
‚îÇ       ‚îî‚îÄ‚îÄ CreateOrder.ts
‚îî‚îÄ‚îÄ infrastructure/
    ‚îî‚îÄ‚îÄ http/
        ‚îú‚îÄ‚îÄ controllers/
        ‚îÇ   ‚îî‚îÄ‚îÄ orderController.ts
        ‚îî‚îÄ‚îÄ routes/
            ‚îî‚îÄ‚îÄ orderRoutes.ts
```

---

## üîë Conceptos Clave

### 1. Tablas Transaccionales
Las tablas transaccionales son tablas intermedias que resuelven relaciones **many-to-many** (muchos a muchos). En lugar de tener una relaci√≥n directa entre dos entidades, se crea una tercera tabla que conecta ambas.

**Ventajas:**
- ‚úÖ Permite relaciones muchos a muchos
- ‚úÖ Almacena informaci√≥n adicional de la relaci√≥n (cantidad, precio, fecha)
- ‚úÖ Normaliza la base de datos
- ‚úÖ Facilita consultas y reportes

### 2. Transacciones de Base de Datos
Las transacciones garantizan que un conjunto de operaciones se ejecuten completamente o ninguna se ejecute (atomicidad).

**En CreateOrder:**
```typescript
const queryRunner = AppDataSource.createQueryRunner();
await queryRunner.startTransaction();

try {
  // Operaciones m√∫ltiples...
  await queryRunner.commitTransaction(); // ‚úÖ Todo bien
} catch (error) {
  await queryRunner.rollbackTransaction(); // ‚ùå Revertir todo
}
```

### 3. Clean Architecture
Separaci√≥n de responsabilidades en capas:

- **Domain:** L√≥gica de negocio pura
- **Application:** Casos de uso y DTOs
- **Infrastructure:** Implementaciones concretas (DB, HTTP)

**Beneficios:**
- ‚úÖ C√≥digo desacoplado
- ‚úÖ F√°cil de testear
- ‚úÖ F√°cil de mantener
- ‚úÖ Independiente de frameworks

---

## üìù Notas Importantes

### Convenci√≥n de Nombres
- Campos en base de datos usan prefijos: `client_email`, `seller_email`, `admin_email`
- Entidades TypeORM usan nombres completos: `ProductCartEntity`, `ProductOrderEntity`
- Relaciones usan nombres claros: `productCarts`, `productOrders`

### Seguridad
- Todos los endpoints de modificaci√≥n requieren autenticaci√≥n
- Middleware `authMiddleware` valida tokens JWT
- Middleware `roleMiddleware` valida roles espec√≠ficos
- Contrase√±as nunca se almacenan en texto plano (bcrypt)

### Variables de Entorno
```env
JWT_SECRET=your-secret-key-change-this-in-production
JWT_EXPIRES_IN=24h
```

---

## üöÄ C√≥mo Funciona el Flujo Completo

### Flujo de Compra Completo:

1. **Cliente se registra/loguea** ‚Üí Recibe JWT token
2. **Cliente ve productos** ‚Üí GET /api/products
3. **Cliente crea carrito** ‚Üí POST /api/carts
4. **Cliente agrega productos al carrito** ‚Üí POST /api/carts/:id/products
   - Se crea registro en **ProductCart**
5. **Cliente actualiza cantidades** ‚Üí PUT /api/carts/:id/products/:productId
   - Se actualiza registro en **ProductCart**
6. **Cliente ve su carrito** ‚Üí GET /api/carts/:id/with-products
   - Devuelve carrito con productos de **ProductCart**
7. **Cliente crea orden** ‚Üí POST /api/orders
   - Se crea orden en **Order**
   - Se crean productos en **ProductOrder** (transacci√≥n)
   - Se actualiza stock de productos
8. **Cliente puede vaciar carrito** ‚Üí DELETE /api/carts/:id/products/:productId
   - Se eliminan registros de **ProductCart**

---

## üéØ Conclusi√≥n

Este proyecto demuestra una implementaci√≥n completa de:

‚úÖ Tablas transaccionales (ProductCart, ProductOrder)  
‚úÖ Clean Architecture en Node.js + TypeScript  
‚úÖ TypeORM con PostgreSQL  
‚úÖ Autenticaci√≥n JWT completa  
‚úÖ Transacciones de base de datos  
‚úÖ API RESTful bien estructurada  
‚úÖ Testing automatizado  

**Todas las operaciones de las tablas transaccionales est√°n probadas y funcionando al 100%.**

---

## üìö Referencias

- [TypeORM Documentation](https://typeorm.io/)
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [JWT Authentication](https://jwt.io/)
- [PostgreSQL Many-to-Many](https://www.postgresql.org/docs/current/tutorial-fk.html)

---

**Fecha de creaci√≥n:** 22 de octubre de 2025  
**Autor:** GitHub Copilot  
**Proyecto:** MarketPlace Espig√≥n Manta
